---
title: Surprise
layout: default
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    margin: 0;
    padding: 20px;
  }
  canvas {
    margin-top: 40px;
  }
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
  }

  #controls {
    margin-top: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .row {
    display: flex;
    justify-content: center;
    margin: 2px 0;
  }

  #controls button {
    font-size: 48px;      /* adjust icon size */
    margin: 1px;
    background: none;      /* remove background */
    border: none;          /* remove border */
    outline: none;         /* remove outline */
    cursor: pointer;       /* pointer on hover */
    color: #555;           /* icon color */
  }

  #controls button:active {
    color: #333;           /* optional pressed effect */
  }
  #controls button:hover {
    color: #333;           /* optional pressed effect */
  }

  #dialogueBox {
  width: 345px;
  min-height: 120px;
  background-color: #f8f8f8;
  border: 4px solid #000;
  border-radius: 8px;
  padding: 10px 16px;
  margin-top: 20px;
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  line-height: 1.5;
  color: #000;
  box-shadow: 4px 4px 0 #333;
  text-align: left;
  position: relative;
}

#dialogueBox::before {
  content: "";
  position: absolute;
  bottom: -4px;
  left: 50%;
  transform: translateX(-50%);
  width: 60%;
  height: 4px;
  background: #000;
  border-radius: 2px;
}

#mazeCanvas {
  border: 4px solid #000;
  border-radius: 8px;
  box-shadow: 4px 4px 0 #333;
  background-color: #dcdcdc; /* subtle background to match Game Boy vibe */
}

#winMessage {
  margin: 0;
  white-space: pre-line;
  min-height: 40px;
}

.typing {
  position: relative;
}

.typing::after {
  content: "";
  display: inline-block;
  width: 2px;
  height: 1em;
  background: #000;
  vertical-align: text-bottom;
  margin-left: 2px;
  animation: blinkCursor 0.8s steps(2, start) infinite;
}

@keyframes blinkCursor {
  to { border-color: transparent; }
}

#dialogueChoices {
  margin-top: 10px;
  display: flex;
  gap: 12px;
}

.dialogue-btn {
  background: #fff;
  border: 2px solid #000;
  border-radius: 4px;
  padding: 4px 10px;
  font-family: 'Press Start 2P', monospace;
  font-size: 14px;
  cursor: pointer;
  box-shadow: 2px 2px 0 #333;
  transition: all 0.1s ease-in-out;
}

.dialogue-btn:hover {
  background: #dcdcdc;
  transform: translateY(-2px);
}

</style>
</head>
<body>

<div id="gameContainer">
  <div id="dialogueBox">
  <p id="winMessage">Explore my website using this maze. Solving the maze will take you to a random page. The maze is procedurally generated and will change each time you visit this page. Enjoy! </p>
  <div id="dialogueChoices"></div>
  </div>
  <canvas id="mazeCanvas" width="380" height="380"></canvas>
  <div id="controls">
    <div class="row">
      <button data-dir="up"><i class="fas fa-circle-up"></i></button>
    </div>
    <div class="row">
      <button data-dir="left"><i class="fas fa-circle-left"></i></button>
      <button data-dir="down"><i class="fas fa-circle-down"></i></button>
      <button data-dir="right"><i class="fas fa-circle-right"></i></button>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');

const tileSize = 40;
const viewWidth = canvas.width;
const viewHeight = canvas.height;
const viewCols = viewWidth / tileSize;
const viewRows = viewHeight / tileSize;
const PLAYER_LERP = 0.8;  // between 0.3â€“0.6 makes motion snappier
const CAMERA_LERP = 0.2;  // higher = snappier camera follow
const MOVE_LERP = 0.6;  // higher = snappier camera follow

function randOdd(max) {
  let r = Math.floor(Math.random() * (max / 2)) * 2 + 1;
  return Math.min(r, max - 2);
}

// === Random Maze Generation ===
function generateMaze(rows, cols, startX = null, startY = null, endX = null, endY = null) {
  const maze = Array.from({ length: rows }, () => Array(cols).fill(1));

  // === Randomize start position if not provided ===
  if (startX === null || startY === null) {
    startX = Math.floor(Math.random() * ((cols - 2) / 2)) * 2 + 1; // odd positions for better carving
    startY = Math.floor(Math.random() * ((rows - 2) / 2)) * 2 + 1;
  }

  maze[startY][startX] = 0;

  // === Depth-First Carving ===
  function carve(x, y) {
    const dirs = [
      [0, -2], [2, 0], [0, 2], [-2, 0]
    ];
    dirs.sort(() => Math.random() - 0.5);

    for (const [dx, dy] of dirs) {
      const nx = x + dx;
      const ny = y + dy;
      if (ny > 0 && ny < rows - 1 && nx > 0 && nx < cols - 1 && maze[ny][nx] === 1) {
        maze[y + dy / 2][x + dx / 2] = 0;
        maze[ny][nx] = 0;
        carve(nx, ny);
      }
    }
  }

  carve(startX, startY);

  // === Keep outer walls solid ===
  for (let i = 0; i < rows; i++) {
    maze[i][0] = maze[i][cols - 1] = 1;
  }
  for (let j = 0; j < cols; j++) {
    maze[0][j] = maze[rows - 1][j] = 1;
  }

  // === Randomize or assign goal ===
  if (endX === null || endY === null) {
    const openCells = [];
    for (let y = 1; y < rows - 1; y++) {
      for (let x = 1; x < cols - 1; x++) {
        if (maze[y][x] === 0 && !(x === startX && y === startY)) {
          openCells.push({ x, y });
        }
      }
    }
    const goal = openCells[Math.floor(Math.random() * openCells.length)];
    endX = goal.x;
    endY = goal.y;
  }

  // Ensure goal tile is open
  maze[endY][endX] = 0;

  return {
    maze,
    start: { x: startX, y: startY },
    end: { x: endX, y: endY }
  };
}


const { maze, start, end } = generateMaze(21, 21);
const rows = maze.length;
const cols = maze[0].length;
const goal = end;

// === Player setup ===
let player = {
  gridX: start.x,
  gridY: start.y,
  x: 1 * tileSize,
  y: 1 * tileSize,
  direction: 'down',
  moving: false,
  frame: 0,
  frameTimer: 0,
  frameInterval: 4,
  animations: {}
};

let camera = { x: start.x, y: start.y };

// Load animation frames
function loadFrames(prefix, count) {
  const frames = [];
  for (let i = 0; i < count; i++) {
    const img = new Image();
    img.src = `/images/${prefix}_${i}.svg`;
    frames.push(img);
  }
  return frames;
}

// --- Auto-load all sprite images dynamically ---
function loadImages(callback) {
  const images = {};

  const baseTypes = ['tree', 'rock', 'floor'];
  const shapes = [
    'isolated',
    'end_up', 'end_right', 'end_down', 'end_left',
    'corner_ur', 'corner_rd', 'corner_dl', 'corner_lu',
    'vertical', 'horizontal',
    't_leftopen', 't_upopen', 't_rightopen', 't_downopen',
    'cross'
  ];

  const extras = [
    // Game objects
    'goal.png',
    // Player idle frames
    'player_idle_down_0.png',
    'player_idle_up_0.png',
    'player_idle_left_0.png',
    'player_idle_right_0.png',
    'player_idle_down_1.png',
    'player_idle_up_1.png',
    'player_idle_left_1.png',
    'player_idle_right_1.png',
    // Player walking frames
    'player_walk_down_0.png',
    'player_walk_down_1.png',
    'player_walk_up_0.png',
    'player_walk_up_1.png',
    'player_walk_left_0.png',
    'player_walk_left_1.png',
    'player_walk_right_0.png',
    'player_walk_right_1.png'
  ];

  // Build file list
  const allPaths = [];

  baseTypes.forEach(type => {
    shapes.forEach(shape => {
      allPaths.push(`${type}_${shape}.png`);
    });
  });

  allPaths.push(...extras);

  let loaded = 0;
  const total = allPaths.length;

  allPaths.forEach(name => {
    const img = new Image();
    img.src = `/images/${name}`;
    img.onload = () => {
      loaded++;
      if (loaded === total) callback();
    };
    const key = name.replace(/\.(svg|png)$/i, ''); // e.g. tree_corner_rd
    images[key] = img;
  });

  // expose images globally so drawMaze can use it
  window.images = images;
}

// --- Build wall sprite map with random wall types ---
const wallSprites = Array.from({ length: rows }, () =>
  Array.from({ length: cols }, () => '')
);

// After randomization, assign proper sprite per tile
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    if (maze[y][x] === 1 || maze[y][x] === 2) {
      // WALL TILE
      const baseType = maze[y][x] === 1 ? 'tree' : 'rock';
      const shape = getEnvironmentSprite(x, y, maze, true);
      wallSprites[y][x] = `${baseType}_${shape}`;
    } else if (maze[y][x] === 0) {
      // FLOOR TILE
      const shape = getEnvironmentSprite(x, y, maze, false);
      wallSprites[y][x] = `floor_${shape}`;
    }
  }
}

function updateCamera() {
  const targetX = player.x + tileSize / 2 - viewWidth / 2;
  const targetY = player.y + tileSize / 2 - viewHeight / 2;
  const maxX = cols * tileSize - viewWidth;
  const maxY = rows * tileSize - viewHeight;

  // Smooth follow
  camera.x = lerp(camera.x, Math.max(0, Math.min(targetX, maxX)), CAMERA_LERP);
  camera.y = lerp(camera.y, Math.max(0, Math.min(targetY, maxY)), CAMERA_LERP);
}

function animatePlayer() {
  player.frameTimer++;
  if (player.frameTimer >= player.frameInterval) {
    player.frameTimer = 0;
    const animKey = player.moving
      ? 'walk' + capitalize(player.direction)
      : 'idle' + capitalize(player.direction);
    const frames = player.animations[animKey];
    if (frames) player.frame = (player.frame + 1) % frames.length;
  }
}

function drawPlayer() {
  const animKey = player.moving
    ? 'walk' + capitalize(player.direction)
    : 'idle' + capitalize(player.direction);
  const frames = player.animations[animKey];
  if (!frames) return;

  const frameIndex = player.frame % frames.length;
  const frame = frames[frameIndex];

  const drawX = player.x - camera.x;
  const drawY = player.y - camera.y;
  ctx.drawImage(frame, drawX, drawY, tileSize, tileSize);
}

// --- Bitmask-based tile selection ---
function getEnvironmentSprite(x, y, maze , isFloor = true) {
  const dirs = [
    { dx: 0, dy: -1, bit: 1 }, // up
    { dx: 1, dy: 0, bit: 2 },  // right
    { dx: 0, dy: 1, bit: 4 },  // down
    { dx: -1, dy: 0, bit: 8 }  // left
  ];

  let mask = 0;
  for (let { dx, dy, bit } of dirs) {
    const nx = x + dx, ny = y + dy;
    const neighborIsWall = maze[ny] && maze[ny][nx] > 0;

    // If it's a floor tile, invert the logic
    if (isFloor ? !neighborIsWall : neighborIsWall) {
      mask |= bit;
    }
  }

  const mapping = {
    0:  'isolated',
    1:  'end_down',
    2:  'end_left',
    4:  'end_up',
    8:  'end_right',
    3:  'corner_ur',
    6:  'corner_rd',
    12: 'corner_dl',
    9:  'corner_lu',
    5:  'vertical',
    10: 'horizontal',
    7:  't_leftopen',
    11: 't_upopen',
    13: 't_rightopen',
    14: 't_downopen',
    15: 'cross'
  };
  return mapping[mask] || 'isolated';
}

function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  updateCamera();

  const startCol = Math.floor(camera.x / tileSize);
  const endCol = Math.ceil((camera.x + viewWidth) / tileSize);
  const startRow = Math.floor(camera.y / tileSize);
  const endRow = Math.ceil((camera.y + viewHeight) / tileSize);
  const offsetX = -camera.x + startCol * tileSize;
  const offsetY = -camera.y + startRow * tileSize;

  for (let y = startRow; y < endRow; y++) {
    for (let x = startCol; x < endCol; x++) {
      const key = wallSprites[y]?.[x];
      if (key && images[key]) {
        const drawX = (x - startCol) * tileSize + offsetX;
        const drawY = (y - startRow) * tileSize + offsetY;
        ctx.drawImage(images[key], drawX, drawY, tileSize, tileSize);
      }
    }
  }

  const drawX = goal.x * tileSize - camera.x;
  const drawY = goal.y * tileSize - camera.y;
  ctx.drawImage(images['goal'], drawX, drawY, tileSize, tileSize);
}

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function movePlayer(dx, dy) {
  if (gameFrozen) return; // stop movement when frozen

  const newX = player.gridX + dx;
  const newY = player.gridY + dy;

  if (maze[newY] && maze[newY][newX] === 0) {
    player.gridX = newX;
    player.gridY = newY;
  }

  player.direction =
    dx > 0 ? "right" : dx < 0 ? "left" : dy > 0 ? "down" : "up";
  checkWin();
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function typeDialogue(text, callback) {
  const msg = document.getElementById('winMessage');
  const choiceBox = document.getElementById('dialogueChoices');
  msg.textContent = "";
  msg.classList.add("typing");
  choiceBox.innerHTML = "";

  let i = 0;
  const speed = 35; // milliseconds per character

  function typeNext() {
    if (i < text.length) {
      msg.textContent += text.charAt(i);
      i++;
      setTimeout(typeNext, speed);
    } else {
      msg.classList.remove("typing");
      if (callback) callback();
    }
  }

  typeNext();
}


function checkWin() {
  const msg = document.getElementById('winMessage');
  const choiceBox = document.getElementById('dialogueChoices');

  // Check grid coords and prevent retrigger
  if (!hasWon && player.gridX === goal.x && player.gridY === goal.y) {
    hasWon = true;
    gameFrozen = true;

    typeDialogue("You solved the maze!\nExplore my website?", () => {
      choiceBox.innerHTML = `
        <button class="dialogue-btn" id="yesBtn">Yes</button>
        <button class="dialogue-btn" id="noBtn">No</button>
      `;

      const yesBtn = document.getElementById("yesBtn");
      const noBtn = document.getElementById("noBtn");

      yesBtn.onclick = () => {
        const sitePages = [
          "/research/solver",
          "/research/translation",
          "/research/multiscale",
          "/publications",
          "/vision",
          "/teaching",
          "/cv",
          "/contact"
        ];
        // Pick a random page from the list
        const randomIndex = Math.floor(Math.random() * sitePages.length);
        const randomPage = sitePages[randomIndex];
        window.location.href = randomPage;
      };

      noBtn.onclick = () => {
        typeDialogue("You decide to keep exploring the maze.", () => {
          choiceBox.innerHTML = "";
          gameFrozen = false;
          hasWon = false; // allow re-trigger
        });
      };
    });
  } 
  else if (!hasWon) {
    // Only log when not at goal
    msg.textContent = "Explore my website using this maze. Solving the maze will take you to a random page. The maze is procedurally generated and will change each time you visit this page. Enjoy!";
    choiceBox.innerHTML = "";
  }
}



// Movement speed (ms per step)
const MOVE_INTERVAL = 300;
let moveInterval = null;
let gameFrozen = false;
let hasWon = false;

// Mapping of direction names to (dx, dy)
const dirs = {
  up: [0, -1],
  down: [0, 1],
  left: [-1, 0],
  right: [1, 0]
};

// --- BUTTON CONTROLS ---
document.querySelectorAll("#controls button").forEach(btn => {
  const dir = btn.dataset.dir;
  const [dx, dy] = dirs[dir];

  // Start moving while pressed/touched
  btn.addEventListener("pointerdown", e => {
    if (gameFrozen) return; // block input while dialogue active
    startMove(dx, dy, e);
  });

  // Stop moving when released or finger lifted
  btn.addEventListener("pointerup", stopMove);
  btn.addEventListener("pointerleave", stopMove); // if you slide off
});

// --- KEYBOARD CONTROLS ---
document.addEventListener("keydown", e => {
  if (gameFrozen) return;

  // Ignore repeated keydown events (we manage hold manually)
  if (e.repeat) return;

  let dx = 0, dy = 0;
  switch (e.key.toLowerCase()) {
    case "arrowup": case "w": dy = -1; break;
    case "arrowdown": case "s": dy = 1; break;
    case "arrowleft": case "a": dx = -1; break;
    case "arrowright": case "d": dx = 1; break;
    default: return;
  }

  e.preventDefault();

  // Clear any existing movement to allow instant direction switch
  if (moveInterval) {
    clearInterval(moveInterval);
    moveInterval = null;
  }

  // Move immediately and start continuous movement
  startMove(dx, dy, e);
});

document.addEventListener("keyup", e => {
  const keys = ["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d"];
  if (keys.includes(e.key.toLowerCase())) stopMove();
});


// --- GLOBAL TOUCH / TAP MOVEMENT ---
let touchInterval = null;
const tapMoveInterval = 300; // ms between repeated moves when holding

document.addEventListener("pointerdown", handlePageTouchStart);
document.addEventListener("pointerup", handlePageTouchEnd);
document.addEventListener("pointercancel", handlePageTouchEnd);

function handlePageTouchStart(e) {
  const target = e.target;
  if (gameFrozen || target.closest("button") || target.closest("a") || target.closest("#dialogueBox")) return;
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const touchX = e.clientX - rect.left;
  const touchY = e.clientY - rect.top;

  // Ignore touches outside the canvas
  if (touchX < 0 || touchY < 0 || touchX > rect.width || touchY > rect.height) return;

  handleTap(touchX, touchY);

  // Tap-and-hold movement (repeat)
  moveInterval = setInterval(() => handleTap(touchX, touchY), MOVE_INTERVAL);
}

function handlePageTouchEnd(e) {
  stopMove();
}

function handleTap(clickX, clickY) {
  // Player center on screen
  const playerCenterX = (player.x - camera.x) + tileSize / 2;
  const playerCenterY = (player.y - camera.y) + tileSize / 2;

  let dx = clickX - playerCenterX;
  let dy = clickY - playerCenterY;

  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  if (absDx < tileSize * 0.2 && absDy < tileSize * 0.2) return;
  
  let moveOptions = [];

  if (absDx > absDy) {
    moveOptions.push([dx > 0 ? 1 : -1, 0]);  // horizontal primary
    moveOptions.push([0, dy > 0 ? 1 : -1]);  // vertical secondary
  } else {
    moveOptions.push([0, dy > 0 ? 1 : -1]);  // vertical primary
    moveOptions.push([dx > 0 ? 1 : -1, 0]);  // horizontal secondary
  }

  for (let [mx, my] of moveOptions) {
    const newX = player.gridX + mx;
    const newY = player.gridY + my;
    if (maze[newY] && maze[newY][newX] === 0) {
      movePlayer(mx, my);
      break;
    }
  }
}

// --- MOVE HELPERS ---
function startMove(dx, dy, event) {
  event.preventDefault();
  if (moveInterval) clearInterval(moveInterval);

  player.moving = true;
  movePlayer(dx, dy); // move once immediately
  moveInterval = setInterval(() => movePlayer(dx, dy), MOVE_INTERVAL);
}

function stopMove() {
  player.moving = false;
  clearInterval(moveInterval);
  moveInterval = null;
}


let lastFrameTime = 0;
const FRAME_INTERVAL = 1000 / 24; // ~45 FPS target

function gameLoop(timestamp) {
  if (timestamp - lastFrameTime >= FRAME_INTERVAL) {
    lastFrameTime = timestamp;

    // Smooth player pixel movement
    const targetPX = player.gridX * tileSize;
    const targetPY = player.gridY * tileSize;
    player.x = lerp(player.x, targetPX, MOVE_LERP);
    player.y = lerp(player.y, targetPY, MOVE_LERP);

    // Smooth camera in sync with player
    const targetCamX = targetPX + tileSize / 2 - viewWidth / 2;
    const targetCamY = targetPY + tileSize / 2 - viewHeight / 2;
    const maxX = cols * tileSize - viewWidth;
    const maxY = rows * tileSize - viewHeight;
    camera.x = lerp(camera.x, Math.max(0, Math.min(targetCamX, maxX)), MOVE_LERP);
    camera.y = lerp(camera.y, Math.max(0, Math.min(targetCamY, maxY)), MOVE_LERP);

    animatePlayer();
    drawMaze();
    drawPlayer();
  }

  requestAnimationFrame(gameLoop);
}

loadImages(() => {
  // === Define player animations here ===
  player.animations = {
    idleUp:    [images.player_idle_up_0, images.player_idle_up_1],
    idleDown:  [images.player_idle_down_0, images.player_idle_down_1],
    idleLeft:  [images.player_idle_left_0, images.player_idle_left_1],
    idleRight: [images.player_idle_right_0, images.player_idle_right_1],

    walkUp:    [images.player_walk_up_0, images.player_walk_up_1],
    walkDown:  [images.player_walk_down_0, images.player_walk_down_1],
    walkLeft:  [images.player_walk_left_0, images.player_walk_left_1],
    walkRight: [images.player_walk_right_0, images.player_walk_right_1]
  };

  drawMaze();
  drawPlayer();
  gameLoop();
});

</script>

</body>
</html>